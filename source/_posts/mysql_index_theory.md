---
title: MySQL索引原理一
date: 2021-06-02 12:49:00
tags: MySQL
categories: 数据库
comments: true
typora-root-url: ../
---

**MySQL引擎**

MySQL存储引擎包含 InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB是事务型引擎，其他的为非事务型引擎。当我们想要查询某个库的存储引擎时，可以使用命令：`show variables like '%storage_engine%'`

关于它们的使用上来说，需要根据各自引擎的特点来选择，比如市面上绝大多数程序开发者都是需要保证程序的事务性，则往往会选择InnoDB作为MySQL的存储引擎；也有一些更注重查询效率且能忍受无事务与低实效就会选择MyISAM。在开发过程中，可以这样指定表的引擎：

```mysql
create table T{...} engine=innodb;
create table T{...} engine=memory;
```

**MySQL索引**

InnoDB是MySQL官方默认的的存储引擎，它天然支持事务、索引、灾难恢复、外键等功能。其中InnoDB包括Btree索引、Hash索引两种，这里重点聊聊索引。

#### Hash索引

hash索引(Hash Index)是基于哈希表实现的，对于每一个指定了hash索引的数据，都会对其计算哈希码，并将其保存在哈希表中。表中记录了哈希码和对应数据的行记录指针，由于数据时随机的所以生成的哈希码也将具有随机性，所以哈希索引表中的数据并不是顺序的。

如下表T(id,name,age)，为name创建哈希索引，插入数据后，将列值[ali,bai,cai]依次做hashcode[322223,311111,322225]，之后再给hashCode排序，[311111,322223,322225],此时源数据却不是原来的顺序。

```mysql
id name age  hash     数据指针（行记录指针）
1  ali  24   311111   第二行数据指针
2  bai  25   322223   第一行数据指针
3  cai  26   322225   第三行数据指针
```

**优点**：针对某一个创建了hash索引的数据，查询时只需要再次做hash获取其哈希码，就能快速的定位到具体的一条数据，查询效率极高！

**缺点**：

1. Hash索引将记录放在内存中的！【内存贵】
2. 索引列存储的是：hash值 + 数据行指针 select * from user where name = "ali"; 查询结果首先是：行指针，而不是具体的数据
3. 如果查询SQL是：from user where age > 18; 范围查询很难找到数据[不支持]，而如果增加：order by，则需要在内存中二次索引(查找)
4. 存在Hash碰撞。新增的数据存在哈希碰撞，碰撞发生时将会在哈希表形成一个链，比如三个K(k1,k2,k3)发生了碰撞(hashcode)，则形成：hashcode->k1->k2->k3，新增时需要遍历索引行地址指针找到相应位置。删除时也是需要遍历该列表。所以哈希碰撞很多时，新增/删除会很耗内存与时间。
5. 对排序支持很差，需要内存在二次排序。

推荐使用hash索引的存储引擎：memory  : 数据是放在内存中的，可以使用hash索引，一般是作为中间表。

#### AHI Hash索引

AHI Hash索引也称为自适应Hash索引，不需要手动去设置某个字段的索引，系统自行决定增加hash索引-维护。出现这种现象也是因为MySQL引擎内部的优化机制，引擎自动对于一些查询热页进行hash索引的建立，以提升查询效率。可以通过参数 `innodb_adaptive_hash_index` 来决定是否开启。默认是打开的。

索引建立原理：InnoDB存储引擎会监控所有查询，如果发现某个数据块访问特别频繁，同时认为建立哈希索引将提升数据查询的性能，将自动为数据创建哈希索引，这个索引也称为自适应哈希索引。过程包括：

1. 查询非聚簇索引时，先根据索引列去索引树查询到数据行主键，在根据主键去主键的聚簇索引查询具体的数据行
2. 系统自动检测，发现某棵非聚簇索引树中的某页成为了热点页，就会对其创建哈希表，下次访问时直接访问哈希表

**优点**：系统自动根据需要创建哈希索引，减少非聚簇索引二次回表的过程，达到O(1)的时间复杂度优化。

**缺点**：自动创建的自适应索引存放在InnoDB的缓冲池中，占用部分内存。

### **BTree索引**

讲到B树索引，这里做一下延伸，从二叉树、二叉排序树、AVL树、B(B-)树、B+树讲解MySQL为什么选择的B+树作为InnoDB的主流索引结构。

##### 二叉树

一个跟节点都只能有两个子节点，且有左右之分。

![图片](/images/mysql_index_theory/640.png)

##### 二叉查找树

二叉查找树相比于二叉树，是对所在节点的值进行了排序，使得二叉查找树存在一定排列规则：

1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值
2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值
3. 左、右子树也分别为二叉排序树(左右子树可为空)
4. 不存在相等的键值节点

如图二叉搜索树：

![图片](/images/mysql_index_theory/640-16478653772361.png)

分析：当我们使用B+树查询数据时，相对比其他的顺序数据结构检索一个元素，会更快。检索元素不是在B树被检索节点左边，就是在它右边。但是：会出现一种特殊的结构：

![图片](/images/mysql_index_theory/640-16478653772372.png)



当遇到这种顺序结构时，和二叉检索树没有任何关系，还是很消耗资源，而且如果插入数据体量很大，则可能二叉树深度会很深。

进阶：基于以上存在递增的数据，现在看看AVl树【平衡二叉搜索树】

##### AVL树

是自平衡二叉查找树，特点是左右子树的高度不会大于1，被称为高度平衡树。在增加/删除的时候都会通过一次或多次旋转来平衡这个树。

1. 当二叉树的所有节点都满足：左子树高度 与 右子树高度的平衡因子：bf >= 1 则认为树是不平衡的，需要调整所谓的左旋和右旋都是以子树为原点的：如b是a的子树，那么旋转就围绕b来进行
2. 如果b是a的左子树，那么就围绕b将a向右旋转，看着就像是a直接掉下来了，掉成了b的右子树。就是：a b互换父子身份，b是a的左子树，左旋：a是b的右子树
3. 如果b是a的右子树，那么就围绕b将a向左旋转，看着就像是a直接掉下来了，掉成了b的左子树。就是：a b互换父子身份，b是a的右子树，左旋：a是b的左子树

根据上面讲述，存在四种破坏平衡的方式：	

- LL：在破坏的根节点的左子树(L)的左子树(L)上插入元素，导致的该根节点不平衡的，我们称之为：LL，需要使用："单右旋" 使之平衡。	
- RR：在破坏的根节点的右子树(R)的右子树(R)上插入元素，导致的该根节点不平衡的，我们称之为：RR，需要使用："单左旋" 使之平衡。	
- LR: 在破坏的根节点的左子树(L)的右子树(R)上插入元素，导致的该根节点不平衡的，我们称之为：LR，需要使用："单左旋、再右旋" 使之平衡。	
- RL: 在破坏的根节点的右子树(R)的左子树(L)上插入元素，导致的该根节点不平衡的，我们称之为：RL，需要使用："单右旋、再左旋" 使之平衡。

插入/删除：当增删树的节点数据时，可能变更树的平衡，此时判断增删元素之后的二叉树是否平衡，依据是：是否每一颗节点树都是符合AVL树的范畴。另外：当增删发生时，且二叉树已经不平衡了，则需要对某棵树进行旋转，旋转的树的选择是：寻找离新插入节点最近的不平衡的树进行调整。

![图片](/images/mysql_index_theory/640-16478653772373.png)

分析：

(1)寻找插入16后，最近的一个不平衡的二叉树：根节点为20			  

(2)分析插入16相对于20的方向：16属于在"20的左子树的右子树上插入元素"，所以属于：LR 模式			 

 (3)基于LR模式，需要对不平衡的树进行：先左旋、再右旋			 

 (4)如果子树比较多，可根据比较小的树进行小范围旋转：左旋：根据14-15进行左旋，右旋：根据：15-20进行右旋

AVL树不适合当MySQL索引：	

1. 如果数据很大：50万，则按照AVL树的形成方式，则会形成一颗庞大的树，深度很深。检索一条数据时会进行寻址找数据并且比对，这都是一个IO操作，IO十分消耗机器资源。	
2. innodb引擎存在概念：Page页（pageSize 16KB），每次和磁盘交互的数据大小都是16kb，称为Page页，每次加载16kb大小的数据	
3. IO过多：每次查询数据都是IO，此时都是跟硬盘打交道	
4. 使用AVL树每次查询数据，都是一个数据的索引，很浪费资源，估计就是几B

##### B树

> 注意：英文原意B-树，其实就是B树，只是翻译的问题。

也叫多路搜索树，平衡多叉树【很好理解，多个分叉，不是两个】 好处：降低磁盘IO

- 每个节点的数据，从一个变成多个
- 每个节点的左右子树，从两个变成了多个
- 每个B树绝对平衡，左右子树高度差不超过 1

我们列一个简单的B树结构：就是一个节点存在多个子节点[1：起码两个左右子树  2：根节点元素个数 = 子节点个数 + 1]

![图片](/images/mysql_index_theory/640-16478653772374.png)

B树的定义：	

1. 树中每个节点的孩子节点最多M个(M >= 2)
2. 除去根节点和叶子节点，其他节点至少有：ceil(M/2)个孩子 注：ceil取上限值
3. 所有叶子节点都在同一层，叶子节点不包含任何关键字信息（叶子节点：没有孩子节点和指向孩子节点的指针，其实这些节点是存在的，只是没有执行性的数据而已）
4. 每个非叶子节点都包含有N个关键信息[n, p1, k1, p2, k2, ... pn, kn]，具体含义就是:

- n：第几块磁盘
- pi：指向子树根的接点，也就是其他磁盘页面地址的数据
- ki：指的是关键字，也就是里边存的元素

B树实操：如下，0按照B树结构存入了一些数据，磁盘3上[假设一个磁盘就一个节点数据]未分裂，是一个孩子

![图片](/images/mysql_index_theory/640-16478653772375.png)

分析：查找29这个数值		

1. 从根节点检索，拿到磁盘1的数据，放到内存中		
2. 此时拿到的磁盘1有：名为17、35的两个数据，以及三个指向其他磁盘地址数据的指针。通过对比发现：17 < 29 < 35，因此我们找到了指针P2	
3. 根据指针P2及其地址，我们找到磁盘块3的数据，放到内存		
4. 此时拿到的磁盘3有：名为26、30的两个数据，以及三个指向其他磁盘地址数据的指针。通过对比发现：26 < 29 < 30，因此我们找到了指针P2
5. 根据指针P2及其地址，我们找到磁盘块8的数据，放到内存		
6. 此时拿到的磁盘8有：名为28、29的两个数据，通过比对我们检索到了29的数据以及其磁盘地址

分析上面检索29的过程，我们经历了三次IO操作、3次内存操作就查询出了数据，所以B树降低了树的深度，利用Page页数据大小，设置的B树节点关键字，大大提高了检索效率。

**B树的高度：**n个关键字，m阶[孩子最多m-1个]的B树，高度是：log(ceil(m/2) * ((n+1)/2)) + 1

##### B+树(平衡多路查找树)

1. B+树是根据文件存储以及其他数据库索引结构演变过来的一种树，是由B(B-)树改造过来的，他与B树的区别在于：
2. B树每个节点都保存有，指向其他磁盘块的地址，而B+树没有存储，这也是B+树在一个块中可以存储更多的数据，从而降低树的高度。B+树的所有叶子节点，都使用指针相连，从大到小排列，检索数据的时候可以再叶子节点从左往右进行检索。而B树需要在叶子节点和内部节点来回移动寻找数据。 (每个叶子节点都存有相邻节点的指针，且从大到小排列，可以快速的定位到具体的元素数据)
3. 基于上面讲的，B树是每个节点都可能找到数据，而B+树则必须找到叶子节点才能检索到数据，B+树更加稳定(B+树非叶子节点存储的都是叶子节点关键数据的指针，叶子节点才存储了数据实际的内存指针。所以每个关键字的查询都会走到叶子节点，且路径长度相当，很稳定。B树是可能在内部节点就找到数据指针了)	

B+树实操：

![图片](/images/mysql_index_theory/640-16478653772376.png)

 叶子节点包含了所有的数据，且都是从小到大排列，每个叶子节点都使用指针相连，组成一个链表的形式，因此更加适用于范围查询。双向链表。

**特点：**1.B+树比B-树更加矮胖，相同的数据量B+树要比B-树在一个磁盘块上存储更多的数据，因此检索效率更高，从而IO更少。

2.根节点元素都存在与叶子节点中，所以认为最终的叶子节点包含了所有的元素，中间节点不存数据只存指针，所以所有数据检索都是要到叶节点，查询稳定。

3.检索单个数据，B-每个节点都存有卫星数据(指针)，所以可能很快查出来，但是当范围查询时，会变得很麻烦：自顶向下检索会形成子节点-父节点来回跳转，检索效率低下。比如相同的B-、B+树，在进行范围查询[3-11]时：

(1) B-树是采取中序遍历，来回检索直至找到范围内的数据[3-11]。

(2)B+树从根节点出发找到范围的下限值3，再从叶子节点获取对应的范围值[3-11] 效率很高。

**B+优点：**	

1. 单一节点存储更多元素，查询IO更少
2. 所以查询都到叶子节点，查询稳定
3. 所有的叶子节点组成有序链表，范围查询更优。

**卫星数据：**就是指的每个节点中的执行实际数据的指针。相应的，B-树每个节点都带有卫星数据，而B+树只有叶子节点才有卫星数据

**聚簇索引、非聚簇索引：**有一个区别：聚簇索引中是直接包含的卫星数据，而非聚簇索引包含的是卫星数据的指针，需要二次寻址找到具体数据。

这一节，只对MySQL的索引结构进行了分析，接下来，对MySQL索引使用进行分析，请看下一节。

#### 引用

link:https://zhuanlan.zhihu.com/p/54102723