---
title: 聊聊Redis缓存常见的问题
date: 2021-05-31 21:10:00
tags: Redis
categories: 缓存
comments: true
typora-root-url: ../
---

> 在使用缓存过程中，常常遇到缓存穿透、缓存击穿，缓存雪崩、缓存预热，这里聊聊这几个问题

### 缓存穿透

用户查询一个不存在的key，系统先去查询缓存，缓存没有再查询DB，最终将结果回写到缓存并返回给用户。这种直接miss缓存并且直接将请求打到DB的现象称为缓存穿透。

危害：当大量这类请求过来，则会导致数据库压力过大而宕机。

**方案一：布隆过滤器**

布隆过滤器采用K个哈希函数将某个key做k次哈希，并将其分布在指定大小的位数组bitmap中，判断时使用相同的方式将候选key做哈希值并与相应位比对，都存在则可认为值存在。但是误判率随着选定的**数组大小**和**错误率fpp**有关。

**优点**：使用简单，可使用guava现成的内存模式和redis模式的实现，且位数组占用空间小，判断效率高；最新的countfilter拥有删除功能。

**缺点：**布隆过滤器有着**"一定不存在"**和**"可能存在"**的特性，所以在判断一定不存在时是准确的，但是当存在时有一定误判率。

**方案二：缓存空值**

```
为每个不存在的key进行缓存空值，并设置合适的过期时间，当系统再次请求时可以快速的拿到数据，避免再次去查询DB；这里要求如果DB对该值进行更新，需要删除掉对应的缓存。做法：拿到不存在的key: xyCache.put(phone, null, 600);优点：实现简单，能快速避免缓存穿透问题。缺点：当大量不存在的key请求，就会缓存大量不存在的key数据。而此期间如若缓存了新值，则需清除该key
```

### 缓存击穿

用户查询一个刚过期的key，如果此时用户并发量比较大，或者改key被多个用户线程访问，此时将会有多个DB查询。这个现象称为缓存击穿。

危害：当大量这类请求过来，则会导致数据库压力过大而宕机。

**方案一：不过期**

这个需要针对当前业务来进行设置，如果此类数据更新不频繁，可以考虑不设置过期时间。

**方案二：互斥锁**

当多个线程访问相同的key时，给查询DB的代码增加互斥锁，并将查询结果回写到缓存，后续线程查询前再尝试一遍查询缓存。

### 缓存雪崩

当某个时刻大量key缓存失效，发生大量的缓存穿透，大量请求打到数据库，导致DB压力过大甚至宕机，最终导致整个服务链路不可用。

**方案一：设置不同的过期时间**

缓存雪崩的根因是因为大量数据在某个时刻同时过期，这样我们可以对他们设置不同的过期时间。具体做法可以是：
1.针对业务，对需要缓存的数据设置一个权重值，根据权重值计算key的缓存过期时间。
2.给定一个指定范围的随机值，让这些key都分布在不同的时刻。

**方案二：互斥锁/队列**

在查询DB时增加互斥锁缓解DB压力，或者将写请求写入等待队列降级DB的压力。做法是当缓存失效且拿不到缓存时，对key进行setnx (mutex key)，此时其他的线程不可获得锁，不能进行操作。

***\*方案三：限流算法：令牌桶\****

```
对进来的流量进行限流，也叫QPS限流，使用的令牌桶算法，按照一定速率将令牌入桶，用户请求进来删除令牌并输入流量，当令牌删除完，则表示桶已满，不再处理拒绝请求。用法：获取令牌桶：RateLimiter globalLimiter = RateLimiter.create(reqLimit);
          限制流量：globalLimiter.tryAcquire()
```

***\*方案四：缓存预热\****

```
通过前置的缓存预热，并定期reload，使缓存存在且有效。这需要使用额外的加载程序，固定加载DB数据到缓存，轮询触发加载任务，使用全量/增量的方式加载数据：保存并读取指定表的最后更新时间戳，并和记录表操作记录最大时间戳对比，如不一样则进行增量的同步数据。
```

***\*方案五：双重缓存\****

```
采取本地缓存，用户请求先拿本地缓存，再拿远程缓存(redis)，最后拿DB，本地缓存时间短，redis缓存时间长。
```

***\*方案六：缓存不过期\****

```
不设置过期时间，将redis作为数据存储系统，不会存在热点数据丢失的问题。
```

***\*方案七：熔断降级\****

```
1.可以在程序中进行降级，可使用hystrix进行熔断，设置类似mock的那种降级处理，返回默认的空值，或者默认返回数据
2.物理降级，配合运维在nginx转发时的降级处理，进行截流，或者分流等人工处理。
```